# Стоп-слова для фильтрации ложных срабатываний GPT
# Эти слова НЕ являются компаниями/персонами, даже если GPT их находит

# Служебные слова и заголовки документов
DOCUMENT_STOPWORDS = {
    # Типы документов
    "счет-фактура", "счет фактура", "счет-фактура №", "счет-фактура № (номер) от",
    "акт", "договор", "накладная", "платежное поручение", "платежное поручение №",
    "реестр", "список", "отчет", "справка", "заявка", "заявление",
    "акт о приемке выполненных работ", "договор подряда", "договор поставки",
    "договор поставки №", "договор поставки № (номер) от",
    
    # Заголовки столбцов
    "наименование", "номер", "дата", "сумма", "итого", "всего", "стоимость",
    "количество", "цена", "адрес", "инн", "кпп", "огрн", "основание",
    "получатель", "отправитель", "продавец", "покупатель", "заказчик", "исполнитель",
    "банк", "банк получателя", "бик", "корр. счет", "расчетный счет", "кор. счет",
    "наименование товара", "наименовании товара", "наименование контрагента",
    "номер регистра", "номер регистра:", "период", "период:", "июль 2023 г.",
    "дата первичного документа", "номер первичного документа", "вид первичного",
    "инн контрагента", "инн/кпп", "инн/кпп продавца",
    
    # Служебные фразы
    "с налогом", "без налога", "с налогами", "с ндс", "без ндс", "в том числе ндс",
    "в том числе ндс (указываются проценты) %",
    "вычисляемый", "вычисляемое", "указывается", "примечание", "комментарий",
    "примечание (если применимо)", "назначение платежа", "назначение платежа..",
    "фактический платеж",
    
    # Виды работ/товаров (общие термины)
    "материалы", "тмц", "оборудование", "работы", "услуги", "товары",
    "смр", "пир", "за услуги", "отгружено",
    "проектно-изыскательские работы", "строительно-монтажные работы",
    "комплекс строительно-монтажных работ", "выполненные работы",
    "по договору", "по договору подряда",
    
    # Разделы и категории
    "капитальные вложения", "капиталовложения", "инфраструктура", "этапы",
    "вид объекта", "вид затрат", "вид документа", "вид первичного",
    "вид понесенных затрат",
    
    # Технические термины
    "объект", "стройка", "объект сзпк", "период", "регистр бу",
    "отнесение к объекту", "наименование контрагента", "номер регистра",
    "отнесение к объекту, указанному в сзпк",
    "отнесение к объекту, указанному в сзпк (указывается наименование объекта)",
    "дополнение…",
    
    # Строки из таблиц и проверок
    "всего по акту", "итого с учетом доп. работ и затрат",
    "сумма затрат с ндс, руб.", "сумма затрат без ндс, руб.",
    "текст в столбец с результатами сверки в случае если проверяемые значения не совпадают (варианты)",
    "вид документа, который нужно проверить",
    "проверка наличия примечания при расхождениях по суммам",
    "проверка актов приемки", "не найден акт приемки",
    "не разделены объекты в акте приемки",
    "сверка данных по разделу",
    "научить",
    
    # Результаты проверок
    "соответствует", "не соответствует", "документ не найден", "нужна ли сверка",
    "есть примечание", "нет примечания", "нужно добавить", "нужна ли сверка",
    
    # Простые слова
    "да", "нет", "если", "нужно", "должен", "можно", "необходимо",
    
    # Коды и сокращения (обычно в кавычках)
    "юм", "вгок", "квик", "реестр квик", "список объектов",
    "гкр",
    
    # Общие фразы из документов
    "дому проекту", "дому инвестиционному", "дому объекту", "дому пункту",
    "пл.п.", "этап 1", "этап 2", "этап 3", "совпадение",
    "нет примечания", "нужно добавить", "нет примечания, нужно добавить",
}

# Паттерны для фильтрации (содержат эти слова)
PATTERN_STOPWORDS = [
    "наименование",
    "столбец",
    "поле",
    "указывается",
    "вычисляемый",
    "проверка",
    "сверка",
    "текст в",
    "варианты",
    "документ не найден",
    "не найден",
    "примечание",
]


def is_stopword(text: str) -> bool:
    """
    Проверяет, является ли текст стоп-словом (не компания/не персона).
    
    Args:
        text: Текст для проверки
        
    Returns:
        True если это стоп-слово, False если может быть компанией
    """
    if not text or len(text.strip()) < 3:
        return True
    
    # Если текст содержит переносы строк - это скорее всего мусор
    if '\n' in text or '\r' in text:
        return True
    
    text_lower = text.lower().strip()
    
    # Убираем кавычки для проверки
    text_clean = text_lower.strip('"«»"\'')
    
    # Если после удаления кавычек текст пустой или слишком короткий
    if len(text_clean) < 3:
        return True
    
    # Прямое совпадение
    if text_clean in DOCUMENT_STOPWORDS:
        return True
    
    # Паттерны
    for pattern in PATTERN_STOPWORDS:
        if pattern in text_clean:
            return True
    
    # Если состоит только из знаков препинания и цифр
    if not any(c.isalpha() for c in text_clean):
        return True
    
    # Если это одно короткое слово (меньше 4 букв) БЕЗ цифр
    words = text_clean.split()
    if len(words) == 1 and len(text_clean) < 4 and not any(c.isdigit() for c in text_clean):
        return True
    
    # Если текст начинается с года (цифры) - скорее всего не компания
    import re
    if re.match(r'^(19|20)\d{2}', text_clean):
        return True
    
    # Если текст в кавычках и содержит год - это код, не компания
    if text.startswith(('«', '"', '"')) and text.endswith(('»', '"', '"')):
        if re.search(r'20\d{2}', text_clean):
            return True
    
    return False


def filter_gpt_results(entities: list[str], debug=False) -> list[str]:
    """
    Фильтрует результаты GPT, удаляя стоп-слова.
    
    Args:
        entities: Список найденных сущностей
        debug: Если True, выводит отладочную информацию
        
    Returns:
        Отфильтрованный список
    """
    import re
    
    filtered = []
    skipped = []
    for entity in entities:
        if not entity or len(entity.strip()) < 3:
            skipped.append((entity, "too short"))
            continue
            
        if is_stopword(entity):
            skipped.append((entity, "is_stopword"))
            continue
        
        # Дополнительная проверка: если в кавычках
        if entity.startswith(('«', '"', '"')) and entity.endswith(('»', '"', '"')):
            # Remove quotes properly
            inner = entity
            for quote_pair in [('«', '»'), ('"', '"'), ('"', '"'), ("'", "'")]:
                if inner.startswith(quote_pair[0]) and inner.endswith(quote_pair[1]):
                    inner = inner[len(quote_pair[0]):-len(quote_pair[1])]
                    break
            inner = inner.strip()
            
            # Если содержит год (2023, 2024, 2025) - это код, не компания
            if re.search(r'20\d{2}', inner):
                skipped.append((entity, "contains year"))
                continue
            
            # Короткие фразы в кавычках (1-3 слова) без ООО/АО - скорее всего заголовки
            words = [w for w in inner.split() if w]  # Убираем пустые
            if len(words) <= 3:
                upper_inner = inner.upper()
                # Если нет ООО/ОАО/АО и нет дефиса (типа НИР-центр) - пропускаем
                has_company_marker = any(marker in upper_inner for marker in ['ООО', 'ОАО', ' АО ', 'ЗАО', 'ПАО'])
                has_hyphen = '-' in inner
                
                if not has_company_marker and not has_hyphen:
                    skipped.append((entity, "short phrase in quotes without company marker"))
                    continue
        
        # Если состоит только из заглавных букв и цифр - скорее всего код (ГКР, ВГОК)
        clean = entity
        for quote in ['«', '»', '"', '"', '"', "'"]:
            clean = clean.replace(quote, '')
        clean = clean.strip()
        if len(clean) <= 6 and clean.isupper() and not any(c in clean for c in ['ООО', 'ОАО']):
            skipped.append((entity, "short uppercase code"))
            continue
        
        filtered.append(entity)
    
    if debug:
        print(f"Filtered {len(entities)} -> {len(filtered)} (skipped {len(skipped)})")
        for entity, reason in skipped[:10]:
            print(f"  SKIP: '{entity[:40]}...' - {reason}")
    
    return filtered
